mod SAMPLER is
  pr RANDOM .
  pr COUNTER .
  pr CONVERSION .

op sampleBerWithP : Float -> Bool .
  op sampleUniWithInt : Nat -> Nat .       
  op genRandom : Float Float -> [Float] .
  var n s : Nat .

  op rand : -> [Float] .
  rl [rnd] : rand => float(random(counter) / 4294967296) .

  op rrand : -> [Rat] .
  rl [rrnd] : rrand => random(counter) / 4294967296 .
	
  var R R1 Min Max : Float .

  eq sampleBerWithP(R) = if rand < R then true else false fi . 
  eq sampleUniWithInt(n) = floor(rrand * n) .
  eq genRandom(Min, Max) = rand * (Max - Min) + Min .

endm

mod AUXILIAR is

protecting NAT . 
protecting FLOAT .
protecting CONVERSION .

sort Contents .
sort Address .

sorts Msg Route .
op _<-_ : Address Contents -> Msg . --- construtor Msg
op _<-_<-_ : Address Address Contents -> Msg . --- construtor Router

sort ActiveMsg .
subsort ActiveMsg < Config .
op {_,_} : Float Msg -> ActiveMsg . --- Mensagem ativa

sort Actor .
sort ActorType . --- (atacante, servidor, client)
sorts Attribute AttributeSet .
subsort Attribute < AttributeSet .
op none : -> AttributeSet .
op _,_ : AttributeSet AttributeSet -> AttributeSet [assoc comm id: none] . --- Concatenar AttributeSET
op <name:_|_> : Address AttributeSet -> Actor . --- construtor actor
 
  op [__] : Msg Msg -> Msg .
  sort Config .
  subsorts Msg ActorType Actor Route < Config .

  sort Object .
  subsort Actor < Object . --- Actor can be represented by a term of sort Object
  subsort Msg < Object . --- Message can be represented by a term of sort Object
  subsort Object < Config .

--- Config
  op none : -> Config .
  op flag : Bool Float -> Config . ---- a flag delimiting execution rounds
  op __ : Config Config -> Config [assoc comm id: none] . --- construtor Config
--- END OF Config

--- SCHEDULER
  sorts Scheduler ScheduleMsg ScheduleList .
  subsorts ScheduleMsg Scheduler < ScheduleList .
  subsort Scheduler ScheduleMsg ScheduleList < Config .
  subsort Msg ActiveMsg < Scheduler .
  subsort Msg ActiveMsg < ScheduleList .

  op {_|_} : Float ScheduleList -> Scheduler .
  op  nil : -> ScheduleList .
  op  _;_ : ScheduleList ScheduleList -> ScheduleList [assoc id: nil] .
  op [_,_,_] : Float Msg Nat -> ScheduleMsg . --- Agendar envio de mensagem
--- END OF SCHEDULER


--- Scheduler Operation
  op insert : Scheduler ScheduleMsg -> Scheduler .
  op insert : ScheduleList ScheduleMsg -> ScheduleList .
  op insertList : Scheduler ScheduleList -> Scheduler .
  op insertList : ScheduleList ScheduleList -> ScheduleList .
--- End of List Operation

  op tick : Config -> Config .
  op mytick : Scheduler -> Config .
  op global-time : Scheduler -> Float .
  op getTime : Config -> Float .
	
  var t1 t2 t gt : Float .
  var C : Config .
  var O O1 : Object .
  var p i : Nat .
  var SL SL' : ScheduleList .
  var e : ScheduleMsg .
  var M1 M2 : Msg .

--- { float | Msg } --> ActiveMsg . 
  eq global-time({ gt | SL }) = gt .
  eq getTime(C {gt | SL}) = gt .  

  eq insert({ gt | SL },e) = { gt | insert(SL,e) } .
  eq insert(SL , [ t2 , M2, 1 ]) = SL .   
  eq insert([ t1 , M1, p ] ; SL , [ t2 , M2, 0 ]) = 
       if t1 < t2 then [ t1 , M1, p ] ; insert(SL, [ t2 , M2, 0 ]) 
                  else ([ t2 , M2, 0 ] ; [ t1 , M1, p ] ; SL) fi .
  eq insert( nil , [ t2 , M2, 0 ]) = [ t2 , M2, 0 ] .


  eq insertList({ gt | SL }, SL') = { gt | insertList(SL, SL') } .
  eq insertList(SL , [t2 , M2, p] ; SL') = insertList( insert(SL, [t2, M2, p]), SL' ) .
  ---eq insertList( nil , SL') = SL' .
  eq insertList( SL , nil ) = SL .

  eq mytick({ gt | [ t1 , M1, p ] ; SL }) = M1 { t1 | SL } .


endm

mod teste is 

protecting NAT . 
protecting FLOAT .
protecting AUXILIAR .
protecting RANDOM .
pr COUNTER .
protecting CONVERSION .
protecting SAMPLER .


vars eleBuf neleBuf : EleBuf .
vars ads nads : Address .
vars f nf li nli : Float .
vars lenP nlenP nBuf maxBufR maxHTTP maxTCP rr sign : Nat .

--- PACKAGES
  op GET : Address -> Contents .
  op POST : Address -> Contents .
  op PRAGMA : Address Nat -> Contents . --- endereço, tamanho do pacote pragma
  op ACK : -> Contents .
  op END : -> Contents .
  op TIMEOUT : Address -> Contents .
  op TIMEOUT : -> Contents .
  op CONTROLLER : -> Contents .
  op REMOVE : Contents -> Contents .
  op CONNECT : -> Contents .
  op FAIL : -> Contents .
  op SYN : Address -> Contents .
  op SYN : -> Contents .
  op GET : -> Contents .
  op REQTIME : Address -> Contents .
  op NTP-REQ : Address -> Contents .
  op ICMP : -> Contents . --- destination port unreachable

  ops spawn spawn-ntp poll restart itimeout : -> Contents .

--- END OF PACKAGES

--- SERVER
  op server:_ : Address -> Attribute .	
  op req-cnt:_ : Float -> Attribute .
  op http-list:_ : NBuffer -> Attribute .
  op tcp-list:_ : NBuffer -> Attribute .
  op router-list:_ : NBuffer -> Attribute .
  op ntp-list:_ : NBuffer -> Attribute .	 
  op cnt:_ : Nat -> Attribute .
  op suc-get:_ : Nat -> Attribute .
--- END OF SERVER 

--- CLIENT
  sorts Status Service .
  ops waiting connected failed : -> Status .
  ops get syn : -> Service .
  op status:_ : Status -> Attribute [gather(&)] .
  op service:_ : Service -> Attribute [gather(&)] .
  op retries:_ : Nat -> Attribute .
  op rep-cnt:_ : Nat -> Attribute .
  op atime:_ : Float -> Attribute .  
  op stime:_ : Float -> Attribute .
  op suc:_ : Nat -> Attribute .  

--- END OF CLIENT 

--- ATTACKER
  ops none get pragma ntp : -> Status .
  op step:_ : Status -> Attribute [gather(&)] .
  op cnt-ntp:_ : Nat -> Attribute .
--- END OF ATTACKER

--- Object names
  op g-syn  :     -> Address .   --- generator
  op g-get  :     -> Address .   --- generator
  op ga : -> Address . --- generator attackers
  op c-syn  : Nat -> Address .   --- clients - syn
  op c-get  : Nat -> Address .   --- clients - syn
  op a : Nat -> Address . --- attackers
  op At : -> Address . --- attacker
  ops server sHTTP sTCP router : -> Address . --- Server
  op sNTP : -> Address .
  op attacker : -> Address .

--- Buffer

  sorts EleBuf Buffer NBuffer .
  subsorts Address Float Buffer < NBuffer .
  subsort NBuffer < Attribute .
  subsort EleBuf < Buffer .
  
--- Elementos do Buffer 
 --- op <____> : Address Float Float Nat -> EleBuf . --- elementos do buffer (id, time da entrada, time da ultima requisição, tamanho get pack)
  op <____> : Address Float Float Contents -> EleBuf .
  op [_|_|_] : Nat Nat Buffer -> NBuffer . --- NBuffer
  ---op __ : Buffer Buffer Buffer -> Buffer [comm assoc id: none] .   --- Construtor Buffer

  op <____> : Address Float Float Contents -> EleBuf .
  op [_|_|_|_|_] : Nat Nat Buffer Nat Nat -> NBuffer . --- NBuffer
  op __ : Buffer Buffer -> Buffer [comm assoc id: none] .   --- Construtor Buffer  
  
  op none : -> Buffer .


  op getAddress : EleBuf -> Address .
  eq getAddress( < ads f li c:Contents > ) = ads . 
  op getAddress : Contents -> Address .
  eq getAddress( NTP-REQ(ads) ) = ads .
  eq getAddress( SYN(ads) ) = ads .
  eq getAddress( REQTIME(ads) ) = ads .
  eq getAddress( TIMEOUT(ads) ) = ads .
  eq getAddress( GET(ads) ) = ads . 
  op getBuffer : NBuffer -> Buffer .
  op getSign : NBuffer -> Nat .
  op getRR : NBuffer -> Nat .
  op getBuffer : NBuffer -> Buffer .
  eq getBuffer( [len-http:Nat | maxBufR | B:Buffer] ) = B:Buffer .
  eq getBuffer( [len-http:Nat | maxBufR | B:Buffer | sign | rr] ) = B:Buffer .
  eq getSign ( [len-http:Nat | maxBufR | B:Buffer | sign | rr] ) = sign .
  eq getRR ( [len-http:Nat | maxBufR | B:Buffer | sign | rr] ) = rr .
---  op getLenGET : Address Buffer -> Nat .
---  eq getLenGET( ads , < ads f li lenP > B:Buffer ) = lenP .  
  op getTime : Address Buffer -> Float .
  eq getTime( ads , < ads f li c:Contents >  B:Buffer ) = f .
  op getContents : Address Buffer -> Contents .
  eq getContents( ads , < ads f li c:Contents >  B:Buffer ) = c:Contents .
  op getLastTime : Address Buffer -> Float .
  eq getLastTime( ads , < ads f li c:Contents > B:Buffer ) = li .

  op getREQ : Contents -> Contents .
  eq getREQ( SYN(ads) ) = SYN .
  eq getREQ( GET(ads) ) = GET . 

--- SEVEN
  var pmod : Float .
  vars tOut tPoll : ScheduleMsg .
  vars P R : Buffer .
  vars NP NR NB : NBuffer .
  sort BufRep .
  op <_,_,_> : NBuffer NBuffer ScheduleMsg -> BufRep .



--- Operadores do Buffer 
  op add : NBuffer EleBuf -> NBuffer .
  op size : NBuffer -> Nat . 
  op remove : Buffer Address -> NBuffer .
  op _in_ : Address Buffer -> Bool .
  op update : NBuffer EleBuf EleBuf -> NBuffer .
  op search : Buffer Float -> Address .
  op lenBuf : Buffer Nat -> Nat .
--- Implementações  

--- APPLICATIONS

  eq add([ len-http:Nat | maxBufR | B:Buffer ] , eleBuf ) = [ s(len-http:Nat) | maxBufR | eleBuf B:Buffer ] . 
  eq size([ len-http:Nat | maxBufR | B:Buffer ]) = len-http:Nat .
  eq update([len-http:Nat | maxBufR | < ads f li c:Contents > B:Buffer], < ads f li c:Contents >, < nads nf nli nc:Contents >) = [ (len-http:Nat) | maxBufR | < nads nf nli nc:Contents > B:Buffer ] .
  eq update([len-http:Nat | maxBufR | B:Buffer], < ads f li c:Contents >, < nads nf nli nc:Contents >) = < ads f li c:Contents > [ (len-http:Nat) | maxBufR | < ads f li c:Contents > B:Buffer ] [owise] .

--- ROUTER
  eq add([ len-http:Nat | maxBufR | B:Buffer | sign | rr ] , eleBuf ) = [ s(len-http:Nat) | maxBufR | eleBuf B:Buffer | sign | rr ] . 
  eq size([ len-http:Nat | maxBufR | B:Buffer | sign | rr ]) = len-http:Nat .
  eq update([len-http:Nat | maxBufR | < ads f li c:Contents > B:Buffer | sign | rr], < ads f li c:Contents >, < nads nf nli nc:Contents >) = [ (len-http:Nat) | maxBufR | < nads nf nli nc:Contents > B:Buffer | sign | rr ] .
  eq update([len-http:Nat | maxBufR | B:Buffer | sign | rr], < ads f li c:Contents >, < nads nf nli nc:Contents >) = < ads f li c:Contents > [ (len-http:Nat) | maxBufR | < ads f li c:Contents > B:Buffer | sign | rr ] [owise] .

  
  ceq search (eleBuf B:Buffer, gt ) = getAddress(eleBuf) 
	if (gt >= (getTime( getAddress(eleBuf) , B:Buffer ) ) + Tc ) .
  eq search(eleBuf B:Buffer, gt ) =  getAddress(eleBuf) [owise] .
    
  
 ceq remove(eleBuf B:Buffer, ads ) = B:Buffer 
  if ads == getAddress(eleBuf) .	
  eq remove(B:Buffer , ads) = B:Buffer [owise] .

  --- *** implementacao do operador IN *** ---
  ceq ads in eleBuf B:Buffer = true 
    if ads == getAddress(eleBuf) .
  eq ads in B:Buffer = false [owise] .

eq lenBuf(eleBuf B:Buffer, i) =  lenBuf(B:Buffer, s(i)) .
eq lenBuf(none, i) = i .


--- Fim do Buffer

***( Funcoes SeVen )***
op accept-prob : Float -> Float .
eq accept-prob(p) = floor(S * Ts) / p .

op swap : Buffer EleBuf Nat -> Buffer .
eq swap(eleBuf B:Buffer, neleBuf, s(i)) = eleBuf swap(B:Buffer, neleBuf, i) .
eq swap(eleBuf B:Buffer, neleBuf, 0) = neleBuf B:Buffer .
eq swap(none, neleBuf, i) = none .
---eq swap(eleBuf B:Buffer, neleBuf, s(i)) = neleBuf B:Buffer .

op reply : Address Buffer Float -> [ScheduleList] .
ceq reply(server, < ads f li c:Contents > B:Buffer, gt) = [gt + delay , (ads <- ACK) , drop?] ; reply(server, B:Buffer, gt)  
if c:Contents := SYN(ads) .
eq reply(server, < ads f li c:Contents > B:Buffer, gt) = reply(server, B:Buffer, gt) [owise] .
eq reply(server , none , gt) = nil .

****( Funcoes SDN )****
ops green yellow red : -> Nat .
eq green = 0 .
eq yellow = 1 .
eq red = 2 .

ops grlim yelim rdlim : -> Float .
eq grlim = 0.75 .
eq yelim = 0.9 .
eq rdlim = 1.0 .
--- AJEITAR DIVISAO POR 0
op SDNController : NBuffer -> NBuffer .

---eq SDNController ( [nBuf | maxBufR | none | rr]) = 0  
---	if (nBuf == 0) . 
ceq SDNController ( [nBuf | maxBufR | B:Buffer | sign | rr]) =  [nBuf | maxBufR | B:Buffer | 0 | 0] 
	if (float(nBuf / maxBufR) < grlim) .
ceq SDNController ( [nBuf | maxBufR | B:Buffer | sign | rr]) = [nBuf | maxBufR | B:Buffer | 1 | rr] 
	if ((float(nBuf / maxBufR) >= grlim) and (float(nBuf / maxBufR) <= yelim)) .
ceq SDNController ( [nBuf | maxBufR | B:Buffer | sign | rr]) = [nBuf | maxBufR | B:Buffer | 2 | rr] 
	if ((float(nBuf / maxBufR) > yelim) and (float(nBuf / maxBufR) <= rdlim)) .

--- eq SDNController( [nBuf | maxBufR | none B:Buffer | sign | rr] ) =  [owise] .

--- REMOVE K elementos

***(op removeK : NBuffer -> NBuffer .
ceq removeK ( [nBuf | maxBufR | eleBuf B:Buffer | rr]) = removeK([nBuf + (-1) | maxBufR | eleBuf B:Buffer])
	if (nBuf > maxBufR) .
eq removeK ( [nBuf | maxBufR | none B:Buffer]) = [nBuf | maxBufR | B:Buffer] [owise] .
--- eq removeK ( [nBuf | maxBufR | none B:Buffer] ) = [nBuf | maxBufR | B:Buffer] [owise] .
***)
***( Variaveis Globais )***

  op arate : Float -> Config .    ---- current attack rate
  op crate : Float -> Config .    ---- current client request rate

  var countAmp : Nat .
  op amplification : ->  Nat .
  op round-robin : -> Nat .
  eq round-robin = 2 .
  op ampliMsg : Nat -> Config .
  ops lenPRAGMA lenGET : -> Nat .
  op ran : Nat -> Bool .
  op len : Nat -> Nat .
  op lenBuf : -> Nat .
  ops Ts Tc S SA LIMIT TCheck : -> [Float] .
  op J  : Float Float -> [Nat] .
  op initDelay : -> [Float] .
  op delay : -> [Float] .
  op drop? : -> [Nat] .
  ops maxRouterSize maxRouterSizeTCP maxRouterSizeHTTP maxListHTTP maxListTCP : -> [Nat] .
  ops newAlpha newRho : -> [Float] .
  eq newAlpha =  float(200 / 4800) . ---0.001666667  . --- atacante 
  eq newRho = float(50 / 4800) .  --- cliente (0.08 - 192)
  eq maxRouterSize = 2 .
  eq maxRouterSizeTCP = 24 .
  eq maxRouterSizeHTTP = 12 .
  eq maxListTCP = 12 .	
  eq maxListHTTP = 12 .
  eq amplification = 24 .

  eq S = 60.0 . --- 15(6), 30 (12), 45(18), 60(24), 75(30) 
  eq SA = 120.0 . 
  eq Ts = 0.4 . 
  eq Tc = 0.4 .
  eq TCheck = 0.1 .
  eq LIMIT = 40.0 .
  eq J(Rho,Alpha) = 7 . --- the maximum number of consecutive time windows a client tries to send REQs to the server before it gives up 
  eq initDelay = 0.05 .
  eq delay = 0.1 .
  eq drop? = 0 .
 --- eq lenPRAGMA = floor(random(3) / 10000000) .
 --- eq lenGET = floor(random(1) / 1000000) . 
  eq lenPRAGMA = 68 .
  eq lenGET = 284 .
  eq ran(N:Nat) = float(random(N:Nat) / 4294967295) > 0.5 .


--- VARIABLES
  vars Ser Cli Actor SerNTP Router : Address . --- Server, Client, Attacker
  var AS : AttributeSet . --- AttributeSet
  vars gt Rho r Alpha p t t' : Float . --- global time
  var  tts : Float . --- Tempo entre um request e um response
  vars i i' j k N len-http len-tcp lHTTP lTCP : Nat . --- contains the count of requests that have already been sent
  var SL : ScheduleList .
---  var CONNECT : Contents .
  var m : Msg .
  vars router-tcp router-http buf-tcp buf-http : Buffer . 
  vars lenPack rr01 rr02 sig1 sig2 suc-get suc-syn : Nat .
  
--- END OF VARIABLES

--- ESTADO INICIAL
var S : Scheduler .
op buffer : -> Buffer .
op attributeS : -> AttributeSet .
op initial : -> Config .
op initStat : -> Config . 
op initState : -> Config . 
op scheduleList : -> ScheduleList .
	
eq initState = flag(true, 1.0) arate(newAlpha) crate(newRho)  ---{ 0.0 | nil } 
	<name: router | req-cnt: (S * Ts) , router-list: [0 | maxRouterSizeTCP | none | 0 | 0], cnt: 0 , suc-get: 0 , none >
	<name: sTCP | tcp-list: [0 | maxListTCP | none], cnt: 0, none >
	<name: sHTTP | http-list: [0 | maxListHTTP | none], cnt: 0, none > 
       <name: sNTP |  cnt: 0 , cnt-ntp: 0 , none > 
	<name: g-syn | server: router,  suc: 0 , cnt: 0 , none > ---(g <- spawn)
        <name: g-get | server: router,  suc: 0 , cnt: 0 , none >
	<name: ga | server: server, cnt: 0 , none >
---	mytick(insert( insert ({ 0.0 | nil } , [ initDelay , (g-syn <- spawn ), 0 ] ), [ initDelay , (g-get <- spawn ), 0 ] ) ) .
	mytick(insert( insert ( insert({ 0.0 | nil } , [ initDelay , (g-syn <- spawn ), 0 ] ), [ initDelay , (g-get <- spawn ), 0 ] ), [ initDelay, (ga <- spawn ), 0 ] )) .
---	mytick(insert( insert ( insert({ 0.0 | nil } , [ initDelay , (g-syn <- spawn ), 0 ] ), [ initDelay , (g-get <- spawn ), 0 ] ) , [TCheck, (router <- CONTROLLER), 0] )) .
---	mytick(insert( insert ({ 0.0 | nil }, [ initDelay , (g-get <- spawn ), 0 ] ) , [TCheck, (router <- CONTROLLER), 0] )) .
----	mytick(insert( insert ({ 0.0 | nil } , [ initDelay , (g-get <- spawn ), 0 ] ) , [TCheck, (router <- CONTROLLER), 0] )) .

--- FIM DO ESTADO INICIAL

--- REESCRITAS ---
  crl[stop] :
     flag(true,r) { gt | SL }
   =>
     flag(false,r) mytick({gt | SL})
      if gt >= 40.00 .

--- SERVER ---
vars P' R' : Buffer .
var mSche : ScheduleMsg .

op emptyServer : -> Actor .
op checkEmpty : Config -> Bool .
eq checkEmpty (emptyServer C:Config) = true .
eq checkEmpty (C:Config) = false [owise] .

ceq ampliMsg (countAmp) 
    <name: sNTP | cnt: i , cnt-ntp: countAmp , AS > 
      (sNTP <- spawn-ntp)
    {gt | SL} 
  = ampliMsg(s(countAmp))
     <name: sNTP | cnt: s(i), cnt-ntp: s(countAmp) , AS >
     <name: a(i) | server: sNTP , status: ntp , AS >
     mytick(insert(insert( { gt | SL } , [ gt + delay  , (router <- SYN( a(i))) , 0 ] ) ,[ gt  , (sNTP <- spawn-ntp), 0 ] ) ) 
---     mytick(insert( { gt | SL } , [ gt, (server <- NTP-REQ(a(i + 100)) ), 0 ] ) ) 
 if countAmp < amplification .

ceq ampliMsg (countAmp) 
    <name: sNTP | cnt: i , cnt-ntp: countAmp , AS > (sNTP <- spawn-ntp)
    {gt | SL} 
  = 
     <name: sNTP | cnt: s(i), cnt-ntp: 0 , AS >
	mytick({ gt | SL })
---     mytick(insert( { gt | SL } , [ gt, (server <- NTP-REQ(a(i + 100)) ), 0 ] ) ) 
 if countAmp >= amplification .
 
 
--- red ampliMsg(0) (sNTP <- spawn-ntp) {1.5000000000000002e-1 | [1.9285714285714284e-1,ga <- spawn,0] ; [2.5e-1,server <- NTP-REQ(a(0)),0] ; [ 4.0000000000000002e-1,server <- TIMEOUT,0]}  <name: sNTP | cnt: 1,cnt-ntp: 1 > .

    rl [ServerNTP] : 
     	flag(true, r) { gt | SL }
     	<name: SerNTP | cnt: i , cnt-ntp: i' , AS > 
    	 (Ser <- REQTIME(Actor)) 
     => flag(gt <= LIMIT * r, r)
	<name: SerNTP | cnt: i , cnt-ntp: i' ,  AS >
        mytick(insert( { gt | SL } ,[ gt, (sNTP <- spawn-ntp), 0 ] ) ) 
	ampliMsg(0) .
 	---mytick({ gt | SL }) . 
	---mytick( insert( { gt | SL }, [ gt + delay , (server <- NTP-REQ(Actor) ), 0] ) ) .

***(    crl [ServerTARGET-NTP] : 
     	flag(true, r) { gt | SL }
     	<name: Ser | req-cnt: p , tcp-list: [len-tcp | router-tcp] , http-list: [len-http | router-http], cnt: i , suc-get: k ,  AS > 
    	 (Ser <- NTP-REQ(Actor)) 
     => flag(gt <= LIMIT * r, r)
	<name: Ser | req-cnt: p , tcp-list: NP , http-list: NR, cnt: i , suc-get: k ,  AS >
	mytick( insert( { gt | SL }, mSche ) ) 
	if < NP, NR, mSche > := sevenRound([len-tcp | router-tcp], [len-http | router-http] , NTP-REQ(Actor), gt, p) .
	--- if sevenRound([len-tcp:Nat | router-tcp], [len-http:Nat | router-http] , NTP-REQ(Actor), gt, p) .

--- red sevenRound([0 | none], [0 | none], NTP-REQ(a(0)), 2.5e-1, 0.0 ) .
)***

--- ROUTER REWRITING
   rl [ROUTER] : 
     	flag(true, r) { gt | SL }
     	<name: Router | req-cnt: p , router-list: [len-tcp | maxBufR | router-tcp | sig1 | rr01], cnt: i , suc-get: k ,  AS > 
    	 (Router <- c:Contents) 
     => flag(gt <= LIMIT * r, r)
	     if ( (len-tcp >= maxRouterSizeTCP) and not(getAddress(c:Contents) in router-tcp) ) then --- se buffer tcp esta cheio e REQ n esta no buffer
		<name: Router | req-cnt: p , router-list: [len-tcp | maxBufR | router-tcp | sig1 | rr01], cnt: i , suc-get: k ,  AS >
		mytick({gt | SL })
             else 
    	        <name: Router | req-cnt: (p + 1.0) , router-list: add( [len-tcp | maxBufR | router-tcp | sig1 | rr01], < getAddress(c:Contents) gt gt c:Contents > ), cnt: i , suc-get: k ,AS >
		 mytick(insert( { gt | SL } , [ gt + delay , (server <- Router <- c:Contents), 0 ] ) )
	    fi .
 ---   if ( (c:Contents == SYN(getAddress(c:Contents))) or (c:Contents == GET(getAddress(c:Contents))) ) . 

--- Remover uma requisição do ROUTER ACTOR		
  rl[ServerRemove]:
	<name: Router | req-cnt: p , router-list: [len-tcp | maxBufR | router-tcp | sig1 | rr01], cnt: i , suc-get: k ,  AS >
	(Actor <- REMOVE(c:Contents)) { gt | SL }
    =>
	if (getAddress(c:Contents) in router-tcp) then
  		<name: Router | req-cnt: p , router-list: [len-tcp + (-1) | maxBufR | remove(router-tcp,Actor) | sig1 | rr01], cnt: i , suc-get: k ,  AS >
		mytick({ gt | SL })
	else
		<name: Router | req-cnt: p , tcp-list: [len-tcp | maxBufR | router-tcp | sig1 | rr01], cnt: i , suc-get: k ,  AS >
		mytick({ gt | SL }) 
	fi .

--- Envia mensagem para o CONTROLLER para aumentar / diminuir o buffuer
---

---op _<-_<-_ : Address Contents Address -> Route . --- construtor Msg
---  Ser <- Router <- SYN(Actor) 
     crl [Server-TCP] : 
---(server <- Router <- c:Contents)
     	flag(true, r) { gt | SL }
     	<name: sTCP | tcp-list: [lTCP | maxTCP | buf-tcp], cnt: i,  AS > 
    	 (Ser <- Router <- c:Contents) 
     => flag(gt <= LIMIT * r, r)
	if(not(getAddress(c:Contents) in buf-tcp)) then
           if (lTCP >= maxListTCP) then --- se buffer tcp esta cheio
		<name: sTCP | tcp-list: [lTCP | maxTCP | buf-tcp], cnt: i,  AS > 
		mytick(insert( insert( { gt | SL } , [ gt + delay , (getAddress(c:Contents) <- poll), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] ) ) 
	   else
	        <name: sTCP | tcp-list: add( [lTCP | maxTCP | buf-tcp], < getAddress(c:Contents) gt gt c:Contents > ), cnt: i,  AS > 
	        mytick(insert( insert( insert( { gt | SL }, [ gt + delay, (getAddress(c:Contents) <- ACK), 0 ] ), [ gt + Tc , (Ser <- TIMEOUT(getAddress(c:Contents))), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] )) 
	   fi
	else
		<name: sTCP | tcp-list: update( [lTCP | maxTCP | buf-tcp], < getAddress(c:Contents) (getTime(getAddress(c:Contents), buf-tcp)) getLastTime(getAddress(c:Contents), buf-tcp) getContents(getAddress(c:Contents), buf-tcp) >, < getAddress(c:Contents) getTime(getAddress(c:Contents), buf-tcp) gt c:Contents > ), cnt: i,  AS > 
		mytick(insert( insert( { gt | SL } , [ gt + delay , (Ser <- TIMEOUT(getAddress(c:Contents))), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] ))
													--- TODO - MUDAR tempo
	fi 
    if (c:Contents == SYN(getAddress(c:Contents))) .

     crl [Server-HTTP]: 
     	flag(true, r) { gt | SL }
     	<name: sHTTP | http-list: [lHTTP | maxHTTP | buf-http], cnt: i,  AS > 
    	 (Ser <- Router <- c:Contents) 
     => flag(gt <= LIMIT * r, r)
  	  if(not(getAddress(c:Contents) in buf-http)) then
             if (lHTTP >= maxListHTTP) then --- se buffer http esta cheio
		  <name: sHTTP | http-list: [lHTTP | maxHTTP | buf-http], cnt: i,  AS > 
			mytick(insert( insert( { gt | SL } , [ gt + delay , (getAddress(c:Contents) <- poll), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] ) ) 
	     else
	          <name: sHTTP | http-list: add( [lHTTP | maxHTTP | buf-http], < getAddress(c:Contents) gt gt c:Contents > ), cnt: i,  AS > 
	           mytick(insert( insert( insert( { gt | SL }, [ gt + delay, (getAddress(c:Contents) <- ACK), 0 ] ), [ gt + Tc , (Ser <- TIMEOUT(getAddress(c:Contents))), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] )) 
	     fi
         else
		 <name: sHTTP | http-list: update( [lHTTP | maxHTTP | buf-http], < getAddress(c:Contents) (getTime(getAddress(c:Contents), buf-http)) getLastTime(getAddress(c:Contents), buf-http) getContents(getAddress(c:Contents), buf-http) >, < getAddress(c:Contents) getTime(getAddress(c:Contents), buf-http) gt c:Contents > ), cnt: i,  AS > 
		mytick(insert( insert( { gt | SL } , [ gt + delay , (Ser <- TIMEOUT(getAddress(c:Contents))), 0 ] ), [gt + delay, getAddress(c:Contents) <- REMOVE(c:Contents), 0] ))
         fi 
    if (c:Contents == GET(getAddress(c:Contents))) . 


***(
    rl[ServerTimeoutReq]: 
       flag(true, r) 
       <name: Ser | req-cnt: p , tcp-list: [len-tcp | router-tcp] , http-list: [len-http | router-http], cnt: i , suc-get: k , AS > 
      (Ser <- TIMEOUT) { gt | SL }
     => flag(gt <= LIMIT * r, r)
	<name: Ser | req-cnt: (floor(S * Ts) + 1.0) , tcp-list: [len-tcp | router-tcp] , http-list: [0 | none], cnt: i , suc-get: k , AS >  
	mytick( insert( insertList( { gt | SL } , reply(Ser, router-tcp, gt) ) , [ gt + Ts , (server <- TIMEOUT), 0] )) . 
)***	

--- Timeout Client
    rl[ServerTimeoutConn]: 
       flag(true, r)
       <name: sTCP | tcp-list: [lTCP | maxTCP | buf-tcp], cnt: i,  AS >	 
       <name: sHTTP | http-list: [lHTTP | maxHTTP | buf-http], cnt: i,  AS >
      (Ser <- TIMEOUT(Actor)) { gt | SL }
     => flag(gt <= LIMIT * r, r) 
       if ((Actor in buf-tcp) and (gt >= (getLastTime(Actor , buf-tcp ) ) + Tc)) then
	      <name: sTCP | tcp-list: [lTCP + (-1) | maxTCP | remove(buf-tcp,Actor)], cnt: i,  AS >	 
       	      <name: sHTTP | http-list: [lHTTP | maxHTTP | buf-http], cnt: i,  AS >
	     mytick(insert( { gt | SL } , [ gt + delay , (Actor <- poll), 0 ] ) ) 
       else
	    if ((Actor in buf-http) and (gt >= (getLastTime(Actor , buf-http ) ) + Tc)) then
	       <name: sTCP | tcp-list: [lTCP | maxTCP | buf-tcp], cnt: i,  AS >	 
       	       <name: sHTTP | http-list: [lHTTP + (-1) | maxHTTP | remove(buf-http,Actor)], cnt: i,  AS >
	     mytick(insert( { gt | SL } , [ gt + delay , (Actor <- poll), 0 ] ) )
	    else
	       <name: sTCP | tcp-list: [lTCP | maxTCP | buf-tcp], cnt: i,  AS >	 
       	       <name: sHTTP | http-list: [lHTTP | maxHTTP | buf-http], cnt: i,  AS >
		mytick({ gt | SL })
	    fi

       fi .
***(       else if ( (Actor in router-http) and (gt > (getLastTime(Actor , router-http ) ) + Tc)) then
	    <name: Ser | req-cnt: p , tcp-list: [len-tcp | router-tcp] , http-list: [len-http + (-1) | remove(router-http, Actor) ], cnt: i , suc-get: k , AS >
	     mytick(insert( { gt | SL } , [ gt + delay , (Actor <- poll), 0 ] ) )  
	else
	   <name: Ser | req-cnt: p , tcp-list: [len-tcp | router-tcp] , http-list: [len-http | router-http], cnt: i , suc-get: k , AS > 
	    mytick({ gt | SL })
         fi 
    fi .)***

--- TODO PRAGMA e ENVIO DE PACOTES PRAGMA PELO ATACANTE

--- END OF SERVER ---

--- CLIENT ---

--- Equação para gerar clientes.
--- Clients coming in at the rate of Rho * S - CLIENTES SYN
    eq crate(Rho)
     <name: g-syn | server: Ser, suc: suc-syn, cnt: i , AS > (g-syn <- spawn) { gt | SL }
     = crate(Rho)
        <name: g-syn | server: Ser , suc: suc-syn, cnt: s(i) , AS > 
        <name: c-syn(i) | server: Ser , retries: 0 , atime: gt , stime: Infinity , status: waiting , service: syn , AS > 
        mytick(insert(insert( { gt | SL } ,
           [ gt  , (c-syn(i) <- poll), 0 ] ) ,
	   [ (1.0  / (Rho * SA)) + (gt)  , (g-syn <- spawn), 0 ] ) ) . 
--- Fim da Equacao

   rl [CliSendSYN] : 
        flag(true, r) crate(Rho) arate(Alpha)
        <name: c-syn(i) | server: Ser , retries: j , status: waiting, service: syn , AS >
        (c-syn(i) <- poll) { gt | SL }
     => flag(gt <= LIMIT * r, r) crate(Rho) arate(Alpha)
        if (j <= J(Rho,Alpha)) then
          <name: c-syn(i) | server: Ser , retries: j , status: waiting, AS >
         --- mytick(insert( insert( { gt | SL }, [ gt + delay, (Ser <- SYN( c-syn(i))), 0 ] ), [ gt + Tc + gt , (c-syn(i) <- poll), 0 ] )) 
	mytick(insert ( { gt | SL}, [ gt + delay, (Ser <- SYN( c-syn(i))), 0 ]  )  ) 
        else
          <name: c-syn(i) | server: Ser , retries: j , status: waiting, AS >
          mytick({ gt | SL })
        fi .
  
    rl [CliRecACK] : --- TODO : mytick({ gt | SL })
        flag(true, r) { gt | SL }
---	<name: g-syn | server: Ser, suc: suc-syn, cnt: i , AS >
	<name: c-syn(i) | server: Ser , stime: Infinity , retries: j , status: waiting, AS > 
        (c-syn(i) <- ACK )
     => flag(gt <= LIMIT * r, r)
---        <name: g-syn | server: Ser, suc: s(suc-syn), cnt: i , AS >
	<name: c-syn(i) | server: Ser , stime: gt , retries: j , status: connected, AS > 
	mytick({ gt | SL }) .
	---mytick(insert( { gt | SL } , [ gt + delay, (Ser <- GET(c(i), len(lenGET)) ), 0 ] ) )  .	
	
  rl [CliConn] : 
        flag(true, r) { gt | SL }
        <name: c-syn(i) | server: Ser , retries: j , status: connected, AS >
       (c-syn(i) <- ACK)
     => flag(gt <= LIMIT * r, r) 
        <name: c-syn(i) | server: Ser , retries: j , status: connected, AS >
	mytick({ gt | SL }) .        
	---mytick(insert( { gt | SL } , [ gt + delay , Ser <- GET(c(i),len(lenGET)), 0 ] ) )  .

   rl[CliNotRestartAfterRemove] :
      flag(true,r) { gt | SL }
      (c-syn(i) <- poll)
      <name: c-syn(i) | server: Ser , retries: j , status: waiting, AS >
     => flag(gt <= LIMIT * r, r)
      <name: c-syn(i) | server: Ser , retries: j , status: waiting, AS > 
      mytick({ gt | SL }) .

   rl[CliNotRestartAfterRemove] :
      flag(true,r) { gt | SL }
      (c-syn(i) <- poll)
      <name: c-syn(i) | server: Ser , retries: j , status: connected, AS >
     => flag(gt <= LIMIT * r, r)
      <name: c-syn(i) | server: Ser , retries: j , status: connected, AS > 
      mytick({ gt | SL }) .
 	

--- END OF CLIENT - SYN ---

--- Clients coming in at the rate of Rho * S - CLIENTES GET
    eq crate(Rho)
     <name: g-get | server: Ser, suc: suc-get , cnt: i , AS > (g-get <- spawn) { gt | SL }
     = crate(Rho)
        <name: g-get | server: Ser , suc: suc-get , cnt: s(i) , AS > 
        <name: c-get(i) | server: Ser , retries: 0 , atime: gt , stime: Infinity , status: waiting , service: get , AS > 
        mytick(insert(insert( { gt | SL } ,
           [ gt  , (c-get(i) <- poll), 0 ] ) ,
	   [ (1.0  / (Rho * SA)) + (gt)  , (g-get <- spawn), 0 ] ) ) . 
--- Fim da Equacao

   rl [CliSendGET] : 
        flag(true, r) crate(Rho) arate(Alpha)
        <name: c-get(i) | server: Ser , retries: j , status: waiting, service: get , AS >
        (c-get(i) <- poll) { gt | SL }
     => flag(gt <= LIMIT * r, r) crate(Rho) arate(Alpha)
        if (j <= J(Rho,Alpha)) then
          <name: c-get(i) | server: Ser , retries: j , status: waiting, AS >
           mytick(insert ( { gt | SL}, [ gt + delay, (Ser <- GET( c-get(i))), 0 ]  )  ) 
	---mytick(insert ( { gt | SL}, [ gt + delay, (Ser <- GET( c(i), len(lenGET) )), 0 ]  )  ) 
        else
          <name: c-get(i) | server: Ser , retries: j , status: waiting, AS >
          mytick({ gt | SL })
        fi .
  
    rl [CliRecACK] : --- TODO : mytick({ gt | SL })
        flag(true, r) { gt | SL }
	<name: c-get(i) | server: Ser , stime: Infinity , retries: j , status: waiting, AS > 
        (c-get(i) <- ACK )
     => flag(gt <= LIMIT * r, r)
	<name: c-get(i) | server: Ser , stime: gt , retries: j , status: connected, AS > 
	mytick({ gt | SL }) .
	---mytick(insert( { gt | SL } , [ gt + delay, (Ser <- GET(c(i), len(lenGET)) ), 0 ] ) )  .	

  rl [CliConn] : 
        flag(true, r) { gt | SL }
        <name: c-get(i) | server: Ser , retries: j , status: connected, AS >
       (c-get(i) <- ACK)
     => flag(gt <= LIMIT * r, r) 
        <name: c-get(i) | server: Ser , retries: j , status: connected, AS >
	mytick({ gt | SL }) .        
	---mytick(insert( { gt | SL } , [ gt + delay , Ser <- GET(c(i),len(lenGET)), 0 ] ) )  .
	
   rl[CliNotRestartAfterRemove] :
      flag(true,r) { gt | SL }
      (c-get(i) <- poll)
      <name: c-get(i) | server: Ser , retries: j , status: waiting, AS >
     => flag(gt <= LIMIT * r, r)
      <name: c-get(i) | server: Ser , retries: j , status: waiting, AS > 
      mytick({ gt | SL }) .


   rl[CliNotRestartAfterRemove] :
      flag(true,r) { gt | SL }
      (c-get(i) <- poll)
      <name: c-get(i) | server: Ser , retries: j , status: connected, AS >
     => flag(gt <= LIMIT * r, r)
      <name: c-get(i) | server: Ser , retries: j , status: connected, AS > 
      mytick({ gt | SL }) . 	

--- END OF CLIENT - GET ---



--- Attackers coming in at the rate of Rho * S
    eq arate(Alpha)
       <name: ga | server: Ser, cnt: i , AS > (ga <- spawn) { gt | SL }
     = arate(Alpha)
        <name: ga | server: Ser , cnt: s(i) , AS > 
        <name: a(i) | server: Ser , status: none , AS >  
        mytick(insert(insert( { gt | SL } ,
           [ gt  , (a(i) <- poll), 0 ] ) ,
	   [ (1.0  / (Alpha * SA)) + (gt)  , (ga <- spawn), 0 ] ) ) . 

--- ATTACKER ---

--- Automato = none -> get -> pragma <-> pragma
  rl [ATSendGET-state-none] : 
        flag(true, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser , status: none , AS > 
        (a(i) <- poll) { gt | SL }
     => flag(gt <= LIMIT * r, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser , status: ntp , AS > 
        mytick(insert( { gt | SL } ,
        [ gt + delay, (Ser <- REQTIME(a(i))), 0 ] ) ) .

   rl [ATSendGET-state-pre-ACK] : 
        flag(true, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser , status: ntp , AS > 
        (a(i) <- ACK) { gt | SL } 
     => flag(gt <= LIMIT * r, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser, status: ntp ,AS >
	mytick({gt | SL}) .
--- 	mytick(insert( insert ( { gt | SL } , [ gt + delay, (Ser <- REQTIME(a(i))), 0 ] ), [ gt + delay + delay, (a(i) <- poll), 0] ) ) .
  
 rl [ATSendGET-state-get] : 
        flag(true, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser , status: ntp , AS > 
        (a(i) <- poll) { gt | SL } 
     => flag(gt <= LIMIT * r, r) arate(Alpha) crate(Rho)
        <name: a(i) | server: Ser, status: ntp ,AS > 
       	mytick({gt | SL}) .


--- END OF ATTACKER ---	


--- *** PVeSTa *** ---

---var P : Float .
vars C C' : Config .
var b : Bool .
var p' : Float .


op countConnected : Float Config -> Float .
op  countClients : Config -> Float .

op countConnected-get : Float Config -> Float .
op countClients-get : Config -> Float .

op countAttackers : Config -> Float .
op countDenialPragma : Config -> Float .
op countConAttacker : Float Config -> Float .
op val : Nat Config -> Float .
op sat : Nat Config -> Bool .
op networkTraffic : Config -> Float .
---op countPragma : Config -> Float .

--- Success Probability
op hasConnected : Nat Config -> Float .
op hasConnected-get : Nat Config -> Float .

eq hasConnected(i, <name: c-syn(i) | status: connected , AS > C ) = 1.0 .
eq hasConnected(i, C) = 0.0 [owise] .

eq hasConnected-get(i', <name: c-get(i') | status: connected , AS > C' ) = 1.0 .
eq hasConnected-get(i', C') = 0.0 [owise] .


eq countConnected(p, <name: c-syn(i) | status: connected , AS > C ) = countConnected(p + 1.0 , C) .
eq countConnected(p,C) = p [owise] .

eq countConnected-get(p', <name: c-get(i') | status: connected , AS > C' ) = countConnected-get(p' + 1.0 , C') .
eq countConnected-get(p',C') = p' [owise] .

eq countConAttacker(p, <name: a(i) | status: pragma , AS > C ) = countConAttacker(p + 1.0 , C) .
eq countConAttacker(p,C) = p [owise] .

eq countClients(<name: g-syn | cnt: i , AS > C) = float(i) .
eq countClients-get(<name: g-get | cnt: i' , AS > C') = float(i') .

eq countAttackers(<name: ga | cnt: i , AS > C) = float(i) .
eq networkTraffic(<name: Ser | cnt: i' , cnt-ntp: k , AS > C) = float(i') .
---eq countPragma(<name: a(i) | server: Ser , cnt-pragma: k, AS > C) = float(k) .

  --- Average time-to-service
  op  avgTTS : Config -> Float .
  op  sumTTS : Float Config -> Float .
 ceq avgTTS(C) = if r > 0.0 then sumTTS(0.0, C) / r else 0.0 fi 
                    if r := countConnected(0.0, C) .

  eq sumTTS(p, <name: c-syn(i) | atime: t , stime: t' , status: connected , AS > C )
     = sumTTS(p + (t' + (- t)), C) .
  eq sumTTS(p, C) = p [owise] .  

eq tick( flag(b, r) C ) = flag(true, r + 1.0) C .

eq sat(0, C) = if hasConnected(0, C) > 0.0 then true else false fi .
eq val(0,C) = countConnected(0.0,C) .
eq val(1,C) = countClients(C) .
eq val(2,C) = countConnected(0.0, C) / countClients(C) .
eq val(3,C') = countConnected-get(0.0, C') .
eq val(4,C') = countClients-get(C') .
eq val(5,C') = countConnected-get(0.0, C') / countClients-get(C') . 
---eq val(3,C) = countConAttacker(0.0,C) .

eq val(6,C) = networkTraffic(C) .
---eq val(6,C) = countPragma(C) .
eq val(7,C) = avgTTS(C) .

endm	

--- print
--- set print attribute on .
--- [print "teste " const  "@" ]

--- TODO  - Checar com o buffer maior, ativar ataque , como medir DISP, 
   
